---
title: "AI Agents in Large Codebases: Vibe Coding vs Augmented Coding"
date: 2025-07-02
draft: false
description: "Over the past few weeks, I've barely written any production code by hand in the big Golang codebase I'm currently working with. Instead, I've fully switched to Cursor, letting AI agents handle most of the coding for me."
---

Over the past few weeks, I've barely written any production code by hand in the big Golang codebase I'm currently working with. Instead, I've fully switched to Cursor, letting AI agents handle most of the coding for me. Honestly, it's been a transformative experience and almost all the code I've delivered was generated by AI.

It wasn't a smooth path to being more productive with AI. At first, I was skeptical of AI agents for real word codebases, and I struggled to use it. Small experiments and PoCs were fun, but using AI in real projects was a lot harder ([it isn't just me](https://www.linkedin.com/posts/gergelyorosz_something-i-hear-very-little-talk-about-activity-7333488796627349505-QZnw)). However, after a lot of trial and error, I noticed a clear pattern: I needed one way of using AI for bigger, production-level codebases, and a different one for greenfields and PoCs.

## Two Modes of AI Coding

In one mode, I focus more on the system's behaviour and I don't care much about the code itself. I just want working software.

In the other, I cared a lot more about code quality. I focused on the system's behaviour, but also on the code itself, its tests, structure, clarity, everything

Neither mode is better, but this mental model helped me get more out of coding agents depending on what I was building.

> In vibe coding you don't care about the code, just the behavior of the system. If there's an error, you feed it back into the genie in hopes of a good enough fix. In augmented coding you care about the code, its complexity, the tests, & their coverage. The value system in augmented coding is similar to hand coding — tidy code that works. It's just that I don't type much of that code.
>
> — Kent Beck

This quote from Kent Beck resonated with me. It put into words, something I had already noticed and now I've started using his terms (vibe coding vs augmented coding) to describe the two modes of using AI agents.

## What's the difference?

At its core, the difference comes down to two main factors: the feedback loop and the level of specification. Vibe coding has longer feedback loops and high-level specs, while augmented code has shorter loops and detailed, precise specs.

Each mode has its strengths, weaknesses depending on the context.

## Vibe coding

Best for PoCs, side projects and low-risk software. You focus on the system's behaviour and little to nothing about the code and its "illities". The value system is, working software even if code is bad and hard to evolve and change.

![Rick Rubin](/images/rick-rubin.jpeg)

> Before, you had to study music for years to play in a symphony. Then punk rock came, and anyone could start a band. That's how I started in music. If you had something to say, you could say it. You didn't need expertise, just your idea and ability to convey it
>
> — Rick Rubin

Rick Rubin's analogy is perfect! Vibe-coding is the punk rock of software development. Instructions are high-level and the agent's boundaries aren't well defined. Prompts might look like this:

*"I have a list of image URLs. I need something that grabs them all, saves them with random filenames, and tells me which ones didn't work."*

The upside here is speed and ease. The downside? You're left dealing with potentially chaotic code, unclear designs, and plenty of surprises during code reviews. Because instructions are broad, providing targeted feedback becomes difficult, and the agent tends to take big steps (or even leaps).

When this style works, it looks like magic. I've experience this myself and also heard others say things like, "I implemented the entire feature with one prompt," or "I replicated X module/software in one day."

Yet, the reality is that most of us aren't regularly dealing with greenfields and PoCs. Also, unlike non-technical folks, we actually care about code quality. Still, vibe code is a fantastic when used in the right context.

## Augmented coding

This is what most of us (programmers) will find ourselves in for day-to-day. You can't simply vibe-code your way through a large and complex codebase.

With augmented coding, the AI agent tackles small, clearly-defined tasks with frequent feedback loops. This enables steering to avoid agents spiralling into a loop of endless hallucination. Prompts are specific, like:

*"I want to update package @/my-package because of X. Outline a detailed plan for review before we begin execution."*

After reviewing the plan, you might prompt:

*"Perfect! Execute step 1, based on the test I wrote. Don't change the test as it defines the expected interface and behaviour"*

Sometimes it's easier to write the first test yourself, then hand it off to the agent. Some things are easier to express in Golang than in English.

The main point is: your prompt is much more specific, and you still own the design of the code. Like Kent Beck said, you want "tidy code that works." It's just that you're not typing most of it.

You can ignore syntax details of the language, but not the fundamentals of good software design.

## Transferrable skills

Knowing the exact syntax of a language is a LOT less valuable now. But some skills are still transferable and matter a lot when working with coding agents.

Being able to break down work into a step-by-step plan, with clear initial tests and tight feedback loops, is key. It gives your AI agent the context it needs. Without enough context, performance drops, especially in complex codebases.

Personally, it feels like most of my coding skills matter less now because of AI agents. But my ability to judge good design, decompose complex systems, and slice big problems into manageable pieces has become far more valuable today.

## Lessons Learned So far

### Vibe coding isn't intrinsically bad

Recently, someone asked me, "Should manager and non technical people use Cursor?", implying it's only for highly technical people. My answer is simple: anyone can use it. You just need to understand the context and know your limitations.

It feels a bit elitist when programmers act like people with little or no coding experience shouldn't be allowed to build working software. Sure, they might ignore design or maintainability. But like Rick Rubin said, you don't need to know music theory to make music.

Vibe coding has its place. Even experienced developers can use it when it fits.

That said, it's not something I will use in serious production codebase. You've got to know the context and pick the right approach for the job.

### AI coding agents aren't for vibe coding only

Using AI agents can make you a better programmer if you know how to use it.

Don't let the size of the codebase stop you. That's not a reason to avoid it.

Your agent is only as good as your ability to explain what needs to change. Be clear. Be specific. And when it makes sense, go beyond English and write test cases, diagrams and describe your expectations in code and design.

### Transferable skills

Your ability to plan the work, break it into small steps, and keep feedback loops short was important before AI agents. Now, it is critical. It might end up being the most important skill left for programmers.

Tight feedback loops and detailed plans keep your agent effective and hallucinations under control.

Planning, incremental execution, and short feedback loops have always mattered, and they still do.

AI compresses the feedback loop. It takes care of the repetitive bits so you can focus on design, structure, and clarity.

Embrace the shift. AI agents are already here and won't go back!